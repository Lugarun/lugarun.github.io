<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Lukas - Keyboard Firmware Update</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/tufte.css" />
        <link rel="stylesheet" href="../css/syntax.css" />

        <!--Favicon-->
        <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
        <link rel="manifest" href="../images/site.webmanifest">    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Lukas Schmidt</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Keyboard Firmware Update</h1>
            <article>
    <section class="header">
        Posted on March 21, 2023
        
    </section>
    <section>
        <p>This blog post is an update on my <a href="./2022-07-31-keyboard.html">split wireless keyboard journey</a>.
Not much has changed in terms of hardware other than that I have added the batteries to the keyboard halfs and made some wrist rests.
What has changed a ton is the firmware and keymap.
After a long period of the keyboard sitting on the corner of my desk, I have finally got them up and running with a keymap that I am happy using on a daily basis.</p>
<p>My keyboard only has 36 keys.
So lots of trickery is required to jam the functionality of 104 keys into this small package.
Most small keyboards do this through a combination of the following:</p>
<ul>
<li><em>layers:</em> Each key on the keyboard does something different when a different ‘layer’ is activated. Layers are typically activated by holding down a key.</li>
<li><em>activation modes:</em> Keys can be assigned multiple functions based on how they are pressed. For example, a long hold might register as a shift keystroke where a tap might be the letter ‘b,’ and a double tap might register as ‘B.’</li>
<li><em>chording:</em> In chording, pressing multiple keys simultaneously activates different functions based on which keys are pressed. This is how <a href="https://en.wikipedia.org/wiki/Stenotype">Stenotype</a> keyboards work.</li>
<li><em>tap dance:</em> Tap dance is activation modes taken so far as to be something else. Keys are pressed multiple times to access different functionality as the main method of multiplexing the functionality of a key. Ben Vallack has a great <a href="https://www.youtube.com/watch?v=XBV0piKtNjI">video</a> about what you can do with this method.</li>
</ul>
<p>After experimentation with my layer-based keymap design that mostly relied on shift key style layers, I discovered home row mods.
Precondition has a great <a href="https://precondition.github.io/home-row-mods">blog post</a> going into the details on what home row mods are and how you might want to use them.
This seemed like a great idea; however, home row mods require some careful fine-tuning to ensure that the timing doesn’t result in lots of accidental modifier activations.
Thankfully, there is a preconfigured keymap called <a href="https://github.com/manna-harbour/miryoku/">Miryoku</a> that has good default values that we can start to experiment with.
Miryoku doesn’t have an implementation for the <a href="http://bluemicro.jpconstantineau.com/">BlueMicro_BLE</a> firmware I was using in the previous post; however, it does have one for <a href="https://zmk.dev/">ZMK</a>.</p>
<p>Switching to ZMK with the Adafruit Feather nRF52 microcontrollers turned out to be a challenge for someone not familiar with the ecosystem.
ZMK doesn’t natively support the Feather; however, there are unmerged <a href="https://github.com/zmkfirmware/zmk/pull/1465">pull requests</a> which seem to have gotten Feathers working.
ZMK is set up so you can easily create your configuration in a separate git repo with GitHub actions to build against the current ZMK repo.
The Miryoku ZMK implementation is simply one of these ZMK configuration repos for you to work with.
It turned out to be pretty straightforward to integrate <a href="https://github.com/tmbutcher">tmbutcher’s</a> configuration into my <a href="https://github.com/Lugarun/miryoku_zmk">Miryoku ZMK configuration</a>.
Welll, it turned out to be pretty straightforward after a month of on-and-off debugging that I am still working on forgetting.</p>
<p>Miryoku has so far been so amazing that I have become hesitant to change anything about it.
The home row mod timings are so good that from the get-go I have had negligible amounts of miss-fires.
As with any few key layout, it takes some time to get used to navigating programs like <a href="https://github.com/tmux/tmux">tmux</a>, <a href="https://kakoune.org/">kakoune</a>, or a <a href="https://xmonad.org/">tiling window manager</a> but the home row mods feel so much better than constant pinky workouts.
One thing I do want to eventually add is a gaming layer, but for now, I haven’t been playing games much, and when I do, it is Rocket League with a controller.</p>
<p>ZMK has so far been a joy to work with.
The next big ZMK steps for me are to fix a Bluetooth connection bug and to work out display support, but I will leave those for another day.</p>
    </section>
</article>

        </main>
    </body>
</html>
